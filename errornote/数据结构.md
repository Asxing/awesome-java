---
typora-root-url: pic
---

## 树

1、二叉树排序规则：

前序遍历：根节点:arrow_right:左子树:arrow_right:右子树

中序遍历：左子树:arrow_right:根节点:arrow_right:右子树

后序遍历：左子树:arrow_right:右子树:arrow_right:根节点

2、具有N个节点的完全二叉树的高度为![img](/313239_1495112414064_2887D443F48C1ECDCDE3474E1848FFF1.png)

3、对于二叉树，插入一个新节点时，插入的节点一定是叶子节点，但是插入时不一定是叶子节点，有可能插入到叶子节点的左边和右边作为叶节点的兄弟。

4、高度为h（h>0）的完全二叉树对应的森林所含的树的个数一定是h。:x:，此处应该为 **满二叉树**

5、树、森林和二叉树的转换

- **树转换为二叉树**

（1）加线。在所有兄弟结点之间加一条连线。

（2）去线。树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。

（3）层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）

![img](https://pic002.cnblogs.com/images/2012/457289/2012110416594150.jpg)

​                       

- **森林转换为二叉树**

（1）把每棵树转换为二叉树。

（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。

 

![img](https://pic002.cnblogs.com/images/2012/457289/2012110417004247.jpg)

- **二叉树转换为树**

是树转换为二叉树的逆过程。

（1）加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。

（2）去线。删除原二叉树中所有结点与其右孩子结点的连线。

（3）层次调整。

![img](https://pic002.cnblogs.com/images/2012/457289/2012110417011138.jpg)

 

- **二叉树转换为森林**

假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。

（1）从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。

（2）将每棵分离后的二叉树转换为树。

 

![img](https://pic002.cnblogs.com/images/2012/457289/2012110417014911.jpg)

6、计算某个二叉树的空指针域为：`2*n - （n-1） =  n+1`

7、在一颗度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是（82）

- 任何一棵树中，节点个数比分支个数多一，分支个数等于：20\*4 + 10\*3 + 1\*2 + 10 = 122，所以这棵树一共有123个节点
- 度不为零的节点数目为：20+10+1+10 = 41
- 叶子节点也就是度为零的接点个数为：123-41=82

8、递归式的先序遍历一个 n 节点，深度为 d 的二叉树，需要栈空间的大小为 d

- 从根向下遍历中，每次先转移到左子树上，而右子树则需要暂存起来，因此至少要需要树的深度大
- 又因为此处的二叉树不是完全二叉树，因此深度 `d ！= logn` ，所以此处的栈大小应该是O(d)

9、在中序线索二叉树中，每一个非空的线索均指向其祖先节点





## 数组

1、线性表可以理解为顺序表、链表、双向链表、循环链表、栈以及队列。

2、C语言中，数组的大小必须在编译时确定，可以在运行时确定大小，即动态开辟空间。

3、数组可以看做基本线性表的一种推广，因此与线性表一样，可以对他进行插入、删除等操作:negative_squared_cross_mark:

- 数组不可以越界插入

4、假设有k个关键字互为同义词，若用线性探测法把这K个关键字存入散列表中，至少要进行`K(k+1)/2`次探测。

5、在C语言中，设有数组定义：char arrays[]="China"；则数组array所占用的空间为（6个字节），因为最后还有一个 `\0` 用来标识字符串的终止。

6、假设要存储一个数据集，数据维持有序，对其的操作只有插入，删除，和顺序遍历，综合存储效率和运行速度，使用`链表`数据结构。

7、和顺序栈相比，链栈有一个比较明显的优势是通常不会出现栈满的情况。

8、最小堆算法![img](/6041628_1491210652875_DAB4FA1405303727F0D956811E3C963D.png)

9、广义表即我们通常所说的列表，它放松了对表元素的原子性的限制，允许他们有自身结构

- 广义表的长度：最大括号中的逗号数+1
- 广义表的深度：展开后含括号的层数

10、定义二维数组时，不能省略第二维的大小，这个是由编译器的原理限制的。

11、解析常见的数据结构的操作性能

![img](/105_1411202746369_3.png)













## 字符串





## 链表







## 栈

1、hanoi 塔总数的移动次数，2^n -1





## 队列

1、针对一个环形队列，判断队列的空和满的状态是：

- 空：头指针和尾指针 相等
- 满：`(尾指针+1) mod M` 相等





## 图

1、采用深度优先搜索的或拓扑排序算法可以判断一个有向图中是否有环。

2、图的遍历分为递归和非递归实现，即为深度遍历和广度遍历。

3、所有的遍历都可以变成非递归，通过使用栈来使用，因为栈可以模拟递归的过程，最开始的操作和状态压倒栈，然后紧接的递归调用一个一个地压进去，然后遇到`return`就返回，相当于是从堆栈弹出来，一个一个地 return 出来。

4、一个n个顶点的连通无向图，其边的个数至少为 n-1 （弱智问题）

5、







## 哈希









## 堆

1、一组记录排序码为(5 11 7 2 3 17),则利用堆排序方法建立的初始堆为

![img](/516342_1464920406274_CB670FBEED60306CE352D99A0EE57BF7.png)

2、



