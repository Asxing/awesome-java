---
typora-root-url: pic
---

## 树

1、二叉树排序规则：

前序遍历：根节点:arrow_right:左子树:arrow_right:右子树

中序遍历：左子树:arrow_right:根节点:arrow_right:右子树

后序遍历：左子树:arrow_right:右子树:arrow_right:根节点

2、具有N个节点的完全二叉树的高度为![img](/313239_1495112414064_2887D443F48C1ECDCDE3474E1848FFF1.png)

3、对于二叉树，插入一个新节点时，插入的节点一定是叶子节点，但是插入时不一定是叶子节点，有可能插入到叶子节点的左边和右边作为叶节点的兄弟。

4、高度为h（h>0）的完全二叉树对应的森林所含的树的个数一定是h。:x:，此处应该为 **满二叉树**

5、树、森林和二叉树的转换

- **树转换为二叉树**

（1）加线。在所有兄弟结点之间加一条连线。

（2）去线。树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。

（3）层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）

![img](https://pic002.cnblogs.com/images/2012/457289/2012110416594150.jpg)

​                       

- **森林转换为二叉树**

（1）把每棵树转换为二叉树。

（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。

 

![img](https://pic002.cnblogs.com/images/2012/457289/2012110417004247.jpg)

- **二叉树转换为树**

是树转换为二叉树的逆过程。

（1）加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。

（2）去线。删除原二叉树中所有结点与其右孩子结点的连线。

（3）层次调整。

![img](https://pic002.cnblogs.com/images/2012/457289/2012110417011138.jpg)

 

- **二叉树转换为森林**

假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。

（1）从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。

（2）将每棵分离后的二叉树转换为树。

 

![img](https://pic002.cnblogs.com/images/2012/457289/2012110417014911.jpg)

6、计算某个二叉树的空指针域为：`2*n - （n-1） =  n+1`

7、在一颗度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是（82）

- 任何一棵树中，节点个数比分支个数多一，分支个数等于：20\*4 + 10\*3 + 1\*2 + 10 = 122，所以这棵树一共有123个节点
- 度不为零的节点数目为：20+10+1+10 = 41
- 叶子节点也就是度为零的接点个数为：123-41=82

8、递归式的先序遍历一个 n 节点，深度为 d 的二叉树，需要栈空间的大小为 d

- 从根向下遍历中，每次先转移到左子树上，而右子树则需要暂存起来，因此至少要需要树的深度大
- 又因为此处的二叉树不是完全二叉树，因此深度 `d ！= logn` ，所以此处的栈大小应该是O(d)

9、在中序线索二叉树中，每一个非空的线索均指向其祖先节点





## 数组

1、线性表可以理解为顺序表、链表、双向链表、循环链表、栈以及队列。

2、C语言中，数组的大小必须在编译时确定，可以在运行时确定大小，即动态开辟空间。

3、数组可以看做基本线性表的一种推广，因此与线性表一样，可以对他进行插入、删除等操作:negative_squared_cross_mark:

- 数组不可以越界插入

4、假设有k个关键字互为同义词，若用线性探测法把这K个关键字存入散列表中，至少要进行`K(k+1)/2`次探测。

5、在C语言中，设有数组定义：char arrays[]="China"；则数组array所占用的空间为（6个字节），因为最后还有一个 `\0` 用来标识字符串的终止。

6、假设要存储一个数据集，数据维持有序，对其的操作只有插入，删除，和顺序遍历，综合存储效率和运行速度，使用`链表`数据结构。

7、和顺序栈相比，链栈有一个比较明显的优势是通常不会出现栈满的情况。

8、最小堆算法![img](/6041628_1491210652875_DAB4FA1405303727F0D956811E3C963D.png)

9、广义表即我们通常所说的列表，它放松了对表元素的原子性的限制，允许他们有自身结构

- 广义表的长度：最大括号中的逗号数+1
- 广义表的深度：展开后含括号的层数

10、定义二维数组时，不能省略第二维的大小，这个是由编译器的原理限制的。

11、解析常见的数据结构的操作性能

![img](/105_1411202746369_3.png)

12、C 语言中定义数组时，下表必须为常数。

13、Name->ID，就是String->int，针对于不同的查找方式，由字符串到数组的，字符串最好用 Hash 或 Tree 来索引，不过由于 Name 不是唯一的，一个 Name 可能对应多个 ID，要用 Linked List做对应过来的结构，所以可以使用Hash + Linked List 或 Tree + Linked List。（Tree 可以用 Trie，复杂度是`O(length(name))` ，其实使用 Hash 会更好一些，理论上复杂度是`O(1)`）

14、ID->Name就是int->String，这个就是使用同时使用 Tree 也是可以快速查找到。

15、在一个元素个数为N的数组中，找到升序排在N/5位置的元素的最优算法时间复杂度是`O(n)`

算法的步骤：

- 将N个元素每5个一组，分成`n/5`组
- 取出每一组中的中位数，任意排序方法，比如插入排序
- 递归的调用selection算法查找上一步中的所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个
- 用x来分割数组，设小于等于x个数为K，大于x的个数即为n-k
- 若 i==k,返回x，若 i<k,在小于x的元素中递归的查找第i小的元素，若i>k，在大于x的元素中递归查找第`i-k`小的元素

16、数组的一般初始化：

```c
int a[10]={  };
int a[]={0};
```

17、线性表中的每一个元素都有一个前驱和一个后继。:x:

解释：第一个元素没有前驱，最后一个没有后驱。

18、数据结构二元组表示为： `A=(D ， R) ， D={01 ， 02 ， 03 ， 04 ， 05 ， 06 ， 07 ， 08 ， 09} ， R={r} ， r={<01 ， 02> ， <01， 03> ， <01 ， 04> ， <02 ， 05> ， <02 ， 06> ， <03 ， 07> ， <03 ， 08> ， <03 ， 09>}` ，则数据结构A是（树型结构） 

​                   1

​        2           3            4

​     5  6      7  8  9

19、线性表的顺序存储结构是一种 `随机存取` 的存储结构，线性表的链式存储结构是一种顺序存取的存储结构。

解释：顺序存储结构中，数据元素存放在一组地址连续的存储单元中，每个数据元素地址可以通过公式：LOC（ai）=LOC（a1）+(i-1) 计算得到，从而实现了随机存取，对于链式存储结构，要对某个节点进行存取，都得从链的头指针指向的结点开始，这是一种顺序存取的存储结构。

20、顺序表和链表

顺序表的特点逻辑上相邻的数据元素，物理存储位置也相邻，并且顺序表的存储空间需要预先分配。

优点：方法简单，很多高级语言都有数组，容易实现

21、short a[100]，sizeof(a) 返回 200

short int ： 2个字节

sizeof 返回的表示的含义如下：

- 数组：编译时分配的数组空间大小
- 指针：存储该指针所用的空间大小
- 类型：该类型所占的空间大小
- 对象：对象的实际占用空间大小
- 函数：函数的返回值所占的空间大小，函数的返回类型不能是`void`

22、对于一个具有n个顶点的无向图，若采用邻接表表示，则存放表头节点的数组大小为：`n`

邻接表的性质，存在多少个节点，就有多少个头结点的数组，每个头结点的数组都指向该结点在图中直接相连的结点。

23、在C语言中，字符串默认每个占一个字节，末尾还有`'\0'`，所以一共是4个字节。

24、数组定义为：`int a[4][5]`，引用 `*（a+1）+2`表示 `a 数组第一行第二列元素的地址`。

a 是一个行指针，a+1 后指向下一行，*（a+1）后变成一个列指针，再 +2 仍为列指针，指向数组a第一行第二列的元素。

25、进行二分法查找的时候，要注意中间数字是向下取整。

注意第一个元素是放在A【1】,一共18个元素，也就是A【1】~A[18]。

第一次： low=1，high=18 ，mid=9(9.5向下取整)。A【3】和A【9】比较。 然后把A【9】右面的包括A【9】全部抛弃掉。

第二次：A[1]~A [8]. mid=4(向下取整)。然后把A【4】右面的包括A【4】全部抛弃掉

第三次：Ａ【１】～Ａ【３】。ｍｉｄ＝２。然后把A【２】左面的包括A【２】全部抛弃掉。

第四次；Ａ【３】和Ａ【３】比较。

26、广义表（Lists，又称列表）是一种非线性的数据结构，是线性表的一种推广，即广义表中放松对元素的原子限制，容许他们具有其自身的结构。

二维数组也可以看成是一维数组，只不过这个一维数组的类型为数组。

27、矩阵不仅是标识多维数组，而且是表示图的重要工具。

28、对线性表采用折半查找，该线性表必须元素按值有序排列，并且采用顺序存储结构。

29、数组操作：

- contact：连接两个或多个数组，将返回连接数组后的副本，不影响原来的数组。
- call：调用一个对象的一个方法，以另一个对象替换当前对象
- js中的函数其实是对象，函数名是对函数对象的引用

30、线性表分为顺序存储结构和链式存储结构：

- 顺序存储结构是用一组地址连续的存储单元一次存储线性表的数据元素
- 链式存储结构是用一组任意的存储单元存储线性表是数据元素

31、集合和线性表的区别：数据元素之间的逻辑关系不同

线性表数据元素之间的逻辑关系是一对一的，例如vector、list、deque、stack

集合的数据结构的实现是：红黑树，既然是树，那么他们元素之间的逻辑关系是一对多的

32、对于n个记录的线性表进行快速排序为减少算法的递归深度，应每次分区后，先处理较短的部分。

解释：在快速培训中，需要使用递归来分别处理左右字段，递归深度可以理解为系统栈保存的深度，先处理短的分段再处理长的分段，可以减少时间复杂度。

如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完，长的递归调用没有进行，它是作为一个整体保存在栈中，所以递归栈中的保留的递归数据少一些。

33、初始关键字记录关键字为（20,15,14,18,21,36,40,10），则以20为基准记录记录的一趟快速排序结束后的结果为：10，15，14，18，20，36，40，21

**快排中选择一个基准值，然后在左右两边分别进行比较排序，所有大于基准值的整数移到基准值右边，所有小于基准值的整数移到基准值左边。**

- 1、20比10大，交换：10，15，14，18，21，36，40，20；
- 2、15比20小，不交换；
- 3、14比20小，不交换；
- 4、18比20小，不交换；
- 5、21比20大，交换：10，15，14，18，20，36，40，21；
- 6、36比20小，不交换；7、40比20小，不交换；所以第一趟结束：**10，15，14，18，20，36，40，21**

34、矩阵中的数据元素可以是不同的数据类型，:negative_squared_cross_mark:

首先矩阵的标识方式是使用数组标识，但是数组的定义就是里面的元素都相同。

35、线性表是具有n个数据元素的有限序列

- 数据：信息的载体，·能够被计算机识别、存储、加工、包括整数、实数、字符串、图像、声音。
- 数据元素：数据的基本单元，也称结点、元素、顶点、记录。一个数据元素可由若干个数据项组成。
- 数据项：具有独立含义的最小标识单元，也称字段，域，属性
- 数据结构：指数据之间的相互关系，即组织形式，有逻辑结构（一般程序中出现的形式）和物理结构之分（内存中的连续存储形式）
  - 逻辑结构：
    - 线性： 非空，仅由一个开始节点和一个终端节点，除首尾节点之外，所有节点均只有一个直接前驱和一个直接后继。如：一维数组、栈、队列、链表、串。
    - 非线性：一个节点可以由多个直接前区和多个直接后继，如多维数组、广义表、树、图。

36、栈的限定在一端插入与删除的线性表，允许插入与删除的一端称为栈顶，不允许插入与删除的另一端称为栈底，栈按照先进后出，或后进先出 组织数据，栈具有记忆作用。

37、矩阵下标从1,1开始，以为数组下标从1开始，

1. 当i>=j时，k=i(i-1)/2+j;
2. 当i<=j时，k=j(j-1)/2+i;

38、二维数组

int *s[8]; //定义一个指针数组，该数组中每个元素是一个指针，每个指针指向哪里就需要程序中后续再定义了。  

int (*s)[8]; //定义一个数组指针，该指针指向含8个元素的一维数组（数组中每个元素是int型）。   

区分int *p[n]; 和int (*p)[n]; 就要看运算符的优先级了。  int *p[n]; 中，运算符[ ]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组。  int (*p)[n]; 中( )优先级高，首先说明p是一个指针，指向一个整型的一维数组。 

39、二位以上的数组其实是一种特殊的广义表

- 数组一旦建立，结构的元素个数和元素间的物理存储关系就不会变化
- 数组采用殊勋存储方式表示。

40、对于数组双层循环，小循环放外面，大循环放里面是没错的，但是当循环时，大数组在内部时，可能夸更多的页，缺页率高或者缓存命中更低。

41、C语言指针

```c
int a[5] = {1,3,5,7,9};
int *p = (int *)(&a+1);
printf(“%d,%d”,*(a+1) ， *(p-1));
```

- `&a`表示一个指向大小为5的数组的指针，那么`（&a+1）` 标识指向大小为5的下一个数组的指针，也就是数组a最后一个元素的下一个位置。
- -1则指向a中最后一个元素，a是保存数组的首地址，`*（a+1）` 保存的是数组第二个地址的值
- p是保存数组a最后一个位置的下一个位置的地址
- *p是指向数组a最后一个位置的下一个位置，值为 -1
- *（p-1）是指向数组a最后一个位置，值为9

42、若数组S[1..n]作为两个栈S1和S2的存储空间，对任何一个栈，只有当[1..n]全满时才不能进行进栈操作。为这两个栈分配空间的最佳方案是：S1的栈底位置为1，S2的栈底位置为n。

- 一个在数组第一个元素，朝着数组索引增加方向增加
- 一个栈顶在数据最后一个元素，朝着数组索引减少方向增加
- 当两个栈的栈顶位置相差1时，数组被写满

43、二维数组时每个元素都为顺序表的顺序表。

44、每种数据结构都具备三种基本运算：插入、删除和搜索。:negative_squared_cross_mark:

- 栈就不具备搜索功能

45、数组一般不做插入和删除操作。

46、广义表的表头为空，并不代表该广义表为空表。

解释：广义表()和(())不同，前者是长度为0的空表，对其不能做求表头和表尾的运算，而后者是长度为I的非空表（不过该表中唯一的一个元素是空表），对其可进行分解，得到的表头和表尾均是空表。

47、要求能够进行较快速地插入和删除，则可选范围为链式存储和散列存储，而再加上要求存储结构能反映元素之间的逻辑关系，则只能选择链式存储了，因为散列技术的记录之间不存在什么逻辑关系，他只和关键字有关联。

48、对两个16K×16K的多精度浮点数二维数组进行矩阵求和时，行优先读取和列优先读取的区别是：`行优先快` 

若在内存中，则数据可以`随机存取`，但内存数据被读取或写入时，所需要的时间与这段信息所在的位置无关，但是在读取和写入磁盘时，其所需要的时间与位置就会有关系。因为在C语言中，数组的存放是按照行优先来存放的，本题的关键考察内存抖动的问题，如果按照列访问则需要跳过一大串内存地址，可能需求的内存地址不在当前页中则需要进行置换，这样需要硬盘IO，减低速度。

49、能够支持随机的插入和删除操作、并具有较好的性能是：链表和哈希表

- 数组定义的时候是通过申请一块连续的内存空间，访问某个元素只需要通过下标就可以，但是随机插入和删除都要移动后面多有的元素，所以数组肯定不行。
- 链表， 非连续的空间，通过指针访问，所以随机插入和删除通过指针之间的操作很方便，但是如果要查询一个数的时候还是得一次遍历所有，但是题目所说的是随机插入和删除。
- 栈，所有的操作都是在栈顶，如果要随机插入或者删除某个数，也必须在对其他数进行操作。
- 队列，通过队头和队尾指针进行读入和删除数据，如果直接在队尾添加数据很方便，但题中所要求的是随机
- 哈希表，通过键值对操作，只要知道相关key就很容易进行读取和删除，插入某个元素也可以通过key很方便

50、数组中通常具有的两种基本的操作就是查找和修改

51、数据结构排序：

![img](https://uploadfiles.nowcoder.net/images/20160817/872256_1471417718241_235CD8164042032013BAC62C1EEB9C0C)

52、静态链表是用数组存储节点数据，模拟链表的实现，但是没有用到指针。

- 每个数组节点包括两部分：data域和cursor（游标），data存储数据，cursor指明下个元素在数组中的下标
- 存取第i个元素时，需要从头遍历到`i-1` 和元素，有第 `i-1` 个节点的`cursor` ，才能知道第i个元素存储的位置，因此和i有关
- 使用数组对元素进行存储，在定义时大小已经确定
- 插入和删除操作无需移动元素，只需要修改`cursor`游标的值即可，就像修改动态链表的指针一样

53、顺序查找不管其是否有序，都进行逐个遍历比较，知道相等为止，其平均时间与查找长度相关。

54、顺序存储结构的优点：存储密度大

55、常用的线性结构有：线性表、堆栈、队列、双队列、数组、串。

常见的非线性结构有：二维数组、多维数组、广义表、树、图。

56、稀疏矩阵可采用压缩存储，仅存储其中的非零元素，存储时除了记下非零元素的值外，还要记录其行标`i`和列表`j` ，即用`（i，j，aij）`三元组表示，由此可得出如下结论：稀疏矩阵可由表示非零元素的三元组及其行、列数唯一确定。

57、对数组元素`a[i][j]`引用的是：

- `*(&a[0][0]+10*i+j) `
- `*(a[i]+j)`
- ` *(*(a+i)+j)`

58、concat 会复制返回一个被连接数组的副本，把b的每个元素都添加到a中。

59、对于不同矩阵应该采用不同的存储方式，:fist_raised: 

特殊矩阵中元素有规律，此阿勇数组存储，对于稀疏矩阵中元素没有规律，所以一般采用三元组或者伪地址表示法。

60、既能较快的查找又便于线性表动态变化的查找方法：分块查找

分块查找算法的优点就是在线性表中插入或删除一个结点时，只需要找到该结点属于的块，比如有n个数，每块有i个数，则找到所在块的时间复杂度为log2(n/i+1)-1，接下来在数组尾插入数即可。如果删除的数不在数组尾，则将最后一个数赋值到删除的那个数。 :sun_with_face:

61、`a[3][4];`，则数组 a 中和元素，数组a的初值不确定 

全局性质数组会被初始化为0，局部性质数组初始化为乱码。

62、C语言中，vector在erase之后，指向下一个元素的位置，其实进行erase操作时将后面所有元素都向前移动，迭代器位置没有移动。itor=array.erase(itor) erase返回下一个元素的地址，相当于给itor一个新值。 （:six:)

63、顺序存储的根据数组指针直接定位，在顺序表的任何位置插入一个数据元素，平均需要移动`n/2`个数据元素，算法效率为`O(n)`

64、数组长度是固定的，所以添加和删除都不常用。

65、C语言中，数组作为参数时，`[]`里的数不起作用，传递的是首元素的地址，32位OS下是4个字节，数组具体有多少个元素，要自己指出，比如`void Func(char str[], int n);` 

66、在C语言中，一维数组的定义方式为：`元素类型 数组名[E]；`其中E为**整型常量表达式**

67、线性表可以分为一般线性表和受限线性表，一般线性表也就是我们通常所说的“线性表”，可以自由的删除和添加结点，受限线性表主要包括栈和队列，受限标识对结点的操作受限制。

对于不同的使用者，一个表结构既可以是栈，也可以是队列，也可以是线性表。

68、一个下三角矩阵中计算元素的地址，一般采用梯形面积的形式进行计算。

69、线性表采用链式存储时，其地址连续与否均可以。





## 字符串





## 链表







## 栈

1、hanoi 塔总数的移动次数，2^n -1





## 队列

1、针对一个环形队列，判断队列的空和满的状态是：

- 空：头指针和尾指针 相等
- 满：`(尾指针+1) mod M` 相等





## 图

1、采用深度优先搜索的或拓扑排序算法可以判断一个有向图中是否有环。

2、图的遍历分为递归和非递归实现，即为深度遍历和广度遍历。

3、所有的遍历都可以变成非递归，通过使用栈来使用，因为栈可以模拟递归的过程，最开始的操作和状态压倒栈，然后紧接的递归调用一个一个地压进去，然后遇到`return`就返回，相当于是从堆栈弹出来，一个一个地 return 出来。

4、一个n个顶点的连通无向图，其边的个数至少为 n-1 （弱智问题）

5、







## 哈希









## 堆

1、一组记录排序码为(5 11 7 2 3 17),则利用堆排序方法建立的初始堆为

![img](/516342_1464920406274_CB670FBEED60306CE352D99A0EE57BF7.png)

2、



