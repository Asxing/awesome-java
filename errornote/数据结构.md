---
typora-root-url: pic
---

## 树

1、二叉树排序规则：

前序遍历：根节点:arrow_right:左子树:arrow_right:右子树

中序遍历：左子树:arrow_right:根节点:arrow_right:右子树

后序遍历：左子树:arrow_right:右子树:arrow_right:根节点

2、具有N个节点的完全二叉树的高度为![img](/313239_1495112414064_2887D443F48C1ECDCDE3474E1848FFF1.png)

3、对于二叉树，插入一个新节点时，插入的节点一定是叶子节点，但是插入时不一定是叶子节点，有可能插入到叶子节点的左边和右边作为叶节点的兄弟。

4、高度为h（h>0）的完全二叉树对应的森林所含的树的个数一定是h。:x:，此处应该为 **满二叉树**

5、树、森林和二叉树的转换

- **树转换为二叉树**

（1）加线。在所有兄弟结点之间加一条连线。

（2）去线。树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。

（3）层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）

![img](https://pic002.cnblogs.com/images/2012/457289/2012110416594150.jpg)

​                       

- **森林转换为二叉树**

（1）把每棵树转换为二叉树。

（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。

 

![img](https://pic002.cnblogs.com/images/2012/457289/2012110417004247.jpg)

- **二叉树转换为树**

是树转换为二叉树的逆过程。

（1）加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。

（2）去线。删除原二叉树中所有结点与其右孩子结点的连线。

（3）层次调整。

![img](https://pic002.cnblogs.com/images/2012/457289/2012110417011138.jpg)

 

- **二叉树转换为森林**

假如一棵二叉树的根节点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。

（1）从根节点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根节点的右孩子存在，则连线删除…。直到所有这些根节点与右孩子的连线都删除为止。

（2）将每棵分离后的二叉树转换为树。

 

![img](https://pic002.cnblogs.com/images/2012/457289/2012110417014911.jpg)

6、计算某个二叉树的空指针域为：`2*n - （n-1） =  n+1`

7、在一颗度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是（82）

- 任何一棵树中，节点个数比分支个数多一，分支个数等于：20\*4 + 10\*3 + 1\*2 + 10 = 122，所以这棵树一共有123个节点
- 度不为零的节点数目为：20+10+1+10 = 41
- 叶子节点也就是度为零的接点个数为：123-41=82

8、递归式的先序遍历一个 n 节点，深度为 d 的二叉树，需要栈空间的大小为 d

- 从根向下遍历中，每次先转移到左子树上，而右子树则需要暂存起来，因此至少要需要树的深度大
- 又因为此处的二叉树不是完全二叉树，因此深度 `d ！= logn` ，所以此处的栈大小应该是O(d)

9、在中序线索二叉树中，每一个非空的线索均指向其祖先节点





## 数组

1、线性表可以理解为顺序表、链表、双向链表、循环链表、栈以及队列。

2、C语言中，数组的大小必须在编译时确定，可以在运行时确定大小，即动态开辟空间。

3、数组可以看做基本线性表的一种推广，因此与线性表一样，可以对他进行插入、删除等操作:negative_squared_cross_mark:

- 数组不可以越界插入

4、假设有k个关键字互为同义词，若用线性探测法把这K个关键字存入散列表中，至少要进行`K(k+1)/2`次探测。

5、在C语言中，设有数组定义：char arrays[]="China"；则数组array所占用的空间为（6个字节），因为最后还有一个 `\0` 用来标识字符串的终止。

6、假设要存储一个数据集，数据维持有序，对其的操作只有插入，删除，和顺序遍历，综合存储效率和运行速度，使用`链表`数据结构。

7、和顺序栈相比，链栈有一个比较明显的优势是通常不会出现栈满的情况。

8、最小堆算法![img](/6041628_1491210652875_DAB4FA1405303727F0D956811E3C963D.png)

9、广义表即我们通常所说的列表，它放松了对表元素的原子性的限制，允许他们有自身结构

- 广义表的长度：最大括号中的逗号数+1
- 广义表的深度：展开后含括号的层数

10、定义二维数组时，不能省略第二维的大小，这个是由编译器的原理限制的。

11、解析常见的数据结构的操作性能

![img](/105_1411202746369_3.png)

12、C 语言中定义数组时，下表必须为常数。

13、Name->ID，就是String->int，针对于不同的查找方式，由字符串到数组的，字符串最好用 Hash 或 Tree 来索引，不过由于 Name 不是唯一的，一个 Name 可能对应多个 ID，要用 Linked List做对应过来的结构，所以可以使用Hash + Linked List 或 Tree + Linked List。（Tree 可以用 Trie，复杂度是`O(length(name))` ，其实使用 Hash 会更好一些，理论上复杂度是`O(1)`）

14、ID->Name就是int->String，这个就是使用同时使用 Tree 也是可以快速查找到。

15、在一个元素个数为N的数组中，找到升序排在N/5位置的元素的最优算法时间复杂度是`O(n)`

算法的步骤：

- 将N个元素每5个一组，分成`n/5`组
- 取出每一组中的中位数，任意排序方法，比如插入排序
- 递归的调用selection算法查找上一步中的所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个
- 用x来分割数组，设小于等于x个数为K，大于x的个数即为n-k
- 若 i==k,返回x，若 i<k,在小于x的元素中递归的查找第i小的元素，若i>k，在大于x的元素中递归查找第`i-k`小的元素

16、数组的一般初始化：

```c
int a[10]={  };
int a[]={0};
```

17、线性表中的每一个元素都有一个前驱和一个后继。:x:

解释：第一个元素没有前驱，最后一个没有后驱。

18、数据结构二元组表示为： `A=(D ， R) ， D={01 ， 02 ， 03 ， 04 ， 05 ， 06 ， 07 ， 08 ， 09} ， R={r} ， r={<01 ， 02> ， <01， 03> ， <01 ， 04> ， <02 ， 05> ， <02 ， 06> ， <03 ， 07> ， <03 ， 08> ， <03 ， 09>}` ，则数据结构A是（树型结构） 

​                   1

​        2           3            4

​     5  6      7  8  9

19、线性表的顺序存储结构是一种 `随机存取` 的存储结构，线性表的链式存储结构是一种顺序存取的存储结构。

解释：顺序存储结构中，数据元素存放在一组地址连续的存储单元中，每个数据元素地址可以通过公式：LOC（ai）=LOC（a1）+(i-1) 计算得到，从而实现了随机存取，对于链式存储结构，要对某个节点进行存取，都得从链的头指针指向的结点开始，这是一种顺序存取的存储结构。

20、顺序表和链表

顺序表的特点逻辑上相邻的数据元素，物理存储位置也相邻，并且顺序表的存储空间需要预先分配。

优点：方法简单，很多高级语言都有数组，容易实现

21、short a[100]，sizeof(a) 返回 200

short int ： 2个字节

sizeof 返回的表示的含义如下：

- 数组：编译时分配的数组空间大小
- 指针：存储该指针所用的空间大小
- 类型：该类型所占的空间大小
- 对象：对象的实际占用空间大小
- 函数：函数的返回值所占的空间大小，函数的返回类型不能是`void`

22、对于一个具有n个顶点的无向图，若采用邻接表表示，则存放表头节点的数组大小为：`n`

邻接表的性质，存在多少个节点，就有多少个头结点的数组，每个头结点的数组都指向该结点在图中直接相连的结点。

23、在C语言中，字符串默认每个占一个字节，末尾还有`'\0'`，所以一共是4个字节。

24、数组定义为：`int a[4][5]`，引用 `*（a+1）+2`表示 `a 数组第一行第二列元素的地址`。

a 是一个行指针，a+1 后指向下一行，*（a+1）后变成一个列指针，再 +2 仍为列指针，指向数组a第一行第二列的元素。

25、进行二分法查找的时候，要注意中间数字是向下取整。

注意第一个元素是放在A【1】,一共18个元素，也就是A【1】~A[18]。

第一次： low=1，high=18 ，mid=9(9.5向下取整)。A【3】和A【9】比较。 然后把A【9】右面的包括A【9】全部抛弃掉。

第二次：A[1]~A [8]. mid=4(向下取整)。然后把A【4】右面的包括A【4】全部抛弃掉

第三次：Ａ【１】～Ａ【３】。ｍｉｄ＝２。然后把A【２】左面的包括A【２】全部抛弃掉。

第四次；Ａ【３】和Ａ【３】比较。

26、广义表（Lists，又称列表）是一种非线性的数据结构，是线性表的一种推广，即广义表中放松对元素的原子限制，容许他们具有其自身的结构。

二维数组也可以看成是一维数组，只不过这个一维数组的类型为数组。

27、矩阵不仅是标识多维数组，而且是表示图的重要工具。

28、对线性表采用折半查找，该线性表必须元素按值有序排列，并且采用顺序存储结构。

29、数组操作：

- contact：连接两个或多个数组，将返回连接数组后的副本，不影响原来的数组。
- call：调用一个对象的一个方法，以另一个对象替换当前对象
- js中的函数其实是对象，函数名是对函数对象的引用

30、线性表分为顺序存储结构和链式存储结构：

- 顺序存储结构是用一组地址连续的存储单元一次存储线性表的数据元素
- 链式存储结构是用一组任意的存储单元存储线性表是数据元素

31、集合和线性表的区别：数据元素之间的逻辑关系不同

线性表数据元素之间的逻辑关系是一对一的，例如vector、list、deque、stack

集合的数据结构的实现是：红黑树，既然是树，那么他们元素之间的逻辑关系是一对多的

32、对于n个记录的线性表进行快速排序为减少算法的递归深度，应每次分区后，先处理较短的部分。

解释：在快速培训中，需要使用递归来分别处理左右字段，递归深度可以理解为系统栈保存的深度，先处理短的分段再处理长的分段，可以减少时间复杂度。

如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完，长的递归调用没有进行，它是作为一个整体保存在栈中，所以递归栈中的保留的递归数据少一些。

## `字符`串





## 链表







## 栈

1、hanoi 塔总数的移动次数，2^n -1





## 队列

1、针对一个环形队列，判断队列的空和满的状态是：

- 空：头指针和尾指针 相等
- 满：`(尾指针+1) mod M` 相等





## 图

1、采用深度优先搜索的或拓扑排序算法可以判断一个有向图中是否有环。

2、图的遍历分为递归和非递归实现，即为深度遍历和广度遍历。

3、所有的遍历都可以变成非递归，通过使用栈来使用，因为栈可以模拟递归的过程，最开始的操作和状态压倒栈，然后紧接的递归调用一个一个地压进去，然后遇到`return`就返回，相当于是从堆栈弹出来，一个一个地 return 出来。

4、一个n个顶点的连通无向图，其边的个数至少为 n-1 （弱智问题）

5、







## 哈希









## 堆

1、一组记录排序码为(5 11 7 2 3 17),则利用堆排序方法建立的初始堆为

![img](/516342_1464920406274_CB670FBEED60306CE352D99A0EE57BF7.png)

2、



